<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0"
    />
    <title>Bubble Bluster</title>
    <script src="https://cdn.jsdelivr.net/npm/@farcade/game-sdk@latest/dist/index.min.js"></script>
    <style>
      body {
        margin: 0;
        padding: 0;
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
        font-family: "Courier New", monospace;
        overflow: hidden;
        touch-action: none;
        -webkit-user-select: none;
        user-select: none;
        -webkit-touch-callout: none;
      }
      #game-container {
        position: relative;
        max-width: 500px;
        width: 100%;
        max-height: 1000px;
        height: calc(100vh - 8px);
        background-image: url("https://w0.peakpx.com/wallpaper/85/248/HD-wallpaper-bubbles-air-bubble-glitter.jpg");
        background-size: cover;
        background-position: center;
        background-repeat: no-repeat;
        overflow: hidden;
        border: 4px solid #00ffcc;
        border-radius: 15px;
        box-shadow: 0 0 20px rgba(0, 255, 204, 0.5);
        box-sizing: border-box;
        touch-action: none;
      }
      #game-canvas {
        display: block;
        width: 100%;
        height: calc(100% - 50px);
        position: absolute;
        top: 50px;
        background: rgba(45, 45, 45, 0.7);
        touch-action: none;
      }
      #header {
        position: absolute;
        top: 0;
        width: 100%;
        height: 50px;
        background: #1a1a1a;
        color: #00ffcc;
        display: flex;
        justify-content: center;
        align-items: center;
        gap: 20px;
        padding: 0 20px;
        box-sizing: border-box;
        pointer-events: none;
      }
      #header span {
        font-size: clamp(12px, 3vw, 16px);
        text-shadow: 0 0 5px rgba(0, 255, 204, 0.7);
      }
      #next-bubbles {
        position: absolute;
        bottom: 10px;
        right: 10px;
        display: flex;
        flex-direction: row;
        gap: 8px;
        z-index: 10;
      }
      .next-bubble {
        width: clamp(16px, 5vw, 24px);
        height: clamp(16px, 5vw, 24px);
        border-radius: 50%;
        border: 2px solid #fff;
      }
      #start-screen {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.5);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        color: #00ffcc;
        text-shadow: 0 0 5px rgba(0, 255, 204, 0.7);
        z-index: 20;
        text-align: center;
      }
      #start-screen h1 {
        font-size: clamp(28px, 7vw, 40px);
        margin-bottom: 20px;
        text-transform: uppercase;
      }
      #start-screen p {
        font-size: clamp(14px, 4vw, 18px);
        max-width: 80%;
        margin-bottom: 30px;
      }
      #character-select-screen {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.5);
        display: none;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        color: #00ffcc;
        text-shadow: 0 0 5px rgba(0, 255, 204, 0.7);
        z-index: 20;
        text-align: center;
      }
      #character-select-screen h1 {
        font-size: clamp(28px, 7vw, 40px);
        margin-bottom: 20px;
        text-transform: uppercase;
        width: 100%;
        text-align: center;
      }
      #character-select-screen .character-options {
        display: flex;
        flex-direction: row;
        gap: 20px;
        align-items: center;
        max-width: 90%;
      }
      .character-option {
        display: flex;
        flex-direction: column;
        align-items: center;
        width: 200px;
        height: 330px;
        padding: 10px;
        background: rgba(20, 20, 20, 1);
        border: 2px solid #00ffcc;
        border-radius: 8px;
        cursor: pointer;
        transition: background 0.2s;
        box-sizing: border-box;
      }
      .character-option:hover {
        background: rgba(0, 255, 204, 0.2);
      }
      .character-option img {
        width: 120px;
        height: 120px;
        margin-bottom: 10px;
      }
      .character-option h2 {
        font-size: clamp(32px, 4vw, 22px);
        margin: 0 0 5px 0;
      }
      .character-option p {
        font-size: clamp(10px, 3vw, 14px);
        color: #00ffcc;
        margin: 2px 0;
        text-align: center;
      }
      #level-screen {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.5);
        display: none;
        justify-content: center;
        align-items: center;
        color: #00ffcc;
        text-shadow: 0 0 5px rgba(0, 255, 204, 0.7);
        font-size: clamp(28px, 7vw, 40px);
        z-index: 20;
        text-transform: uppercase;
      }
      .btn {
        padding: clamp(8px, 2.5vw, 12px) clamp(16px, 4vw, 24px);
        font-size: clamp(14px, 3.5vw, 18px);
        cursor: pointer;
        background: #ff0066;
        color: white;
        border: none;
        border-radius: 8px;
        text-shadow: 0 0 5px rgba(255, 0, 102, 0.7);
      }
      .btn:hover {
        background: #ff3385;
      }
    </style>
  </head>
  <body>
    <div id="game-container">
      <div id="header">
        <span id="score">Score: 0</span>
        <span id="level">Level: 1</span>
        <span id="time">Time: 0s</span>
      </div>
      <canvas id="game-canvas"></canvas>
      <div id="next-bubbles">
        <div id="next1" class="next-bubble"></div>
        <div id="next2" class="next-bubble"></div>
      </div>
      <div id="start-screen">
        <h1>Bubble Bluster</h1>
        <p id="instructions"></p>
        <button id="start-btn" class="btn">Game Start</button>
      </div>
      <div id="character-select-screen">
        <h1>Choose Your Character</h1>
        <div class="character-options">
          <div class="character-option select-character" data-character="Toshi">
            <img
              src="https://lqy3lriiybxcejon.public.blob.vercel-storage.com/Y58Z5vSLnB41/toshi-4o9WiIZ3mV0Ixu3C9WVZM1jGXFsFey.png?Demq"
              alt="Toshi"
            />
            <h2>Toshi</h2>
            <p>Skill: Neon Bubble</p>
            <p>Cooldown: 40s</p>
            <p>
              Next bubble becomes neon blue. On impact, removes all bubbles of
              the hit color.
            </p>
          </div>
          <div class="character-option select-character" data-character="Mochi">
            <img
              src="https://lqy3lriiybxcejon.public.blob.vercel-storage.com/Y58Z5vSLnB41/mochi-6Shv9LOkNI74v14diZwSST2xvTxLhz.png?mAoe"
              alt="Mochi"
            />
            <h2>Mochi</h2>
            <p>Skill: Wild Bubble</p>
            <p>Cooldown: 20s</p>
            <p>
              Next bubble acts as a wildcard, connecting with any adjacent
              color.
            </p>
          </div>
        </div>
      </div>
      <div id="level-screen">
        <h1>Level <span id="level-number">1</span></h1>
      </div>
      <audio id="bgm">
        <source id="bgm-source" src="" type="audio/mpeg" />
        Your browser does not support the audio element.
      </audio>
    </div>

    <script>
      const canvas = document.getElementById("game-canvas");
      const ctx = canvas.getContext("2d");
      const scoreDisplay = document.getElementById("score");
      const levelDisplay = document.getElementById("level");
      const timeDisplay = document.getElementById("time");
      const instructions = document.getElementById("instructions");
      const next1 = document.getElementById("next1");
      const next2 = document.getElementById("next2");
      const startScreen = document.getElementById("start-screen");
      const characterSelectScreen = document.getElementById(
        "character-select-screen"
      );
      const levelScreen = document.getElementById("level-screen");
      const bgm = document.getElementById("bgm");
      const bgmSource = document.getElementById("bgm-source");

      // Game constants
      const GRID_WIDTH = 8;
      let BUBBLE_SIZE;
      const GRID_HEIGHT = 14;
      const ALL_COLORS = [
        "#FF0000", // Red
        "#00FF00", // Green
        "#0000FF", // Blue
        "#FFFF00", // Yellow
        "#FF00FF", // Magenta
      ];
      const NEON_BLUE = "#00ffcc"; // Neon blue for special bubble
      let COLORS = [];
      const HEADER_HEIGHT = 50;
      let LIMIT_LINE_Y = 0;
      const BASE_SCORE_PER_LEVEL = 1000;
      const MAX_TIME_BONUS = 5000;
      const TIME_BONUS_DECREASE = 50;
      const BASE_SHOTS_PER_CEILING_DROP = 5; // Reduced from 8
      const ABILITY_COOLDOWN_TOSHI = 40000; // 40 seconds for Toshi
      const ABILITY_COOLDOWN_MOCHI = 20000; // 20 seconds for Mochi
      const SPEECH_BUBBLE_DURATION = 2000; // 2 seconds in milliseconds

      // Music tracks
      const musicTracks = [
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/Y58Z5vSLnB41/retro-game-music-245230-t3lDfWOigoA1V09Piz6TAELdlQ4wzd.mpeg?Kmyu",
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/Y58Z5vSLnB41/8-bit-retro-game-music-233964-05Qr3Rr4tLhisYkFeqlkWvc0H5R9dq.mpeg?UxMx",
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/Y58Z5vSLnB41/level-iii-294428-qud1YQbagnOWtA7TSUDINswBlf7Ii2.mpeg?NnTo",
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/Y58Z5vSLnB41/retro-game-arcade-236133-cD0ddckxG003A916BaDw01qUsA2rdD.mpeg?ZAQ9",
      ];
      let currentTrackIndex = 0;

      // Speech bubble messages
      const largeMatchMessages = [
        "Wooow!",
        "Amazing!",
        "Great job!",
        "Incredible!",
        "Fantastic!",
      ];

      // Game state
      let grid = [];
      let currentBubble = null;
      let nextBubbles = [];
      let launcherAngle = Math.PI / 2;
      let totalScore = 0;
      let gameOver = false;
      let gameStarted = false;
      let particles = [];
      let touchStartX = null;
      let keysPressed = { left: false, right: false };
      let keyPressedThisFrame = { left: false, right: false };
      let isMuted = false;
      let canShoot = true;
      let audioContext = null;
      let currentLevel = 1;
      let levelStartTime = 0;
      let shotCount = 0;
      let ceilingOffset = 0; // Ceiling offset in pixels
      let selectedCharacter = null; // Selected character
      let abilityAvailable = true;
      let lastAbilityUse = 0;
      let abilityCooldown = 0;
      let speechBubble = null; // { text, duration, opacity }

      // Load character images
      const characterImages = {
        Toshi: new Image(),
        Mochi: new Image(),
      };
      characterImages.Toshi.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/Y58Z5vSLnB41/toshi-4o9WiIZ3mV0Ixu3C9WVZM1jGXFsFey.png?Demq";
      characterImages.Mochi.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/Y58Z5vSLnB41/mochi-6Shv9LOkNI74v14diZwSST2xvTxLhz.png?mAoe";

      // Detect if mobile device
      const isMobile = /Mobi|Android|iPhone|iPad|iPod|Touch/.test(
        navigator.userAgent
      );

      // Resize canvas
      function resizeCanvas() {
        try {
          const container = document.getElementById("game-container");
          const containerWidth = Math.min(500, container.clientWidth);
          const containerHeight = Math.min(1000, container.clientHeight);

          canvas.width = containerWidth;
          canvas.height = containerHeight - HEADER_HEIGHT;
          canvas.style.width = `${containerWidth}px`;
          canvas.style.height = `${containerHeight - HEADER_HEIGHT}px`;

          BUBBLE_SIZE = canvas.width / GRID_WIDTH;
          LIMIT_LINE_Y = canvas.height - (isMobile ? 120 : 150); // Raised game over line

          if (next1 && next2) {
            next1.style.width = `${clamp(16, (5 * canvas.width) / 100, 24)}px`;
            next1.style.height = `${clamp(16, (5 * canvas.width) / 100, 24)}px`;
            next2.style.width = `${clamp(16, (5 * canvas.width) / 100, 24)}px`;
            next2.style.height = `${clamp(16, (5 * canvas.width) / 100, 24)}px`;
          }
        } catch (error) {
          console.error("Canvas resize error:", error);
        }
      }
      function clamp(min, val, max) {
        return Math.max(min, Math.min(max, val));
      }
      resizeCanvas();
      window.addEventListener("resize", resizeCanvas, { passive: true });

      // Initialize audio context
      function initAudioContext() {
        try {
          if (!audioContext) {
            audioContext = new (window.AudioContext ||
              window.webkitAudioContext)();
            return true;
          }
        } catch (error) {
          console.error("Audio context initialization error:", error);
        }
        return false;
      }

      // Play background music
      function playBgm() {
        try {
          if (!isMuted && bgm) {
            bgmSource.src = musicTracks[currentTrackIndex];
            bgm.load();
            bgm.play().catch((error) => {
              console.error("BGM playback error:", error);
            });
          }
        } catch (error) {
          console.error("BGM error:", error);
        }
      }

      // Switch to next music track
      function nextTrack() {
        try {
          currentTrackIndex = (currentTrackIndex + 1) % musicTracks.length;
          playBgm();
        } catch (error) {
          console.error("Next track error:", error);
        }
      }

      // Cleanup audio
      function cleanupAudio() {
        try {
          if (bgm) {
            bgm.pause();
            bgm.currentTime = 0;
          }
          if (audioContext) {
            audioContext.close().catch((error) => {
              console.error("Audio context cleanup error:", error);
            });
            audioContext = null;
          }
        } catch (error) {
          console.error("Audio cleanup error:", error);
        }
      }

      // Show level screen
      function showLevelScreen() {
        const levelNumber = document.getElementById("level-number");
        if (levelScreen && levelNumber) {
          levelNumber.textContent = currentLevel;
          levelScreen.style.display = "flex";
          canShoot = false;
          setTimeout(() => {
            levelScreen.style.display = "none";
            canShoot = true;
            levelStartTime = performance.now();
            shotCount = 0; // Reset shot counter
            ceilingOffset = 0; // Reset ceiling offset
          }, 2000);
        }
      }

      // Lower ceiling (increment ceilingOffset)
      function lowerCeiling() {
        try {
          ceilingOffset += (BUBBLE_SIZE * Math.sqrt(3)) / 2; // Move down one row
          // Haptic feedback if available
          if (window.FarcadeSDK) {
            window.FarcadeSDK.singlePlayer.actions.hapticFeedback();
          }
        } catch (error) {
          console.error("Lower ceiling error:", error);
        }
      }

      // Initialize game
      function init() {
        try {
          grid = Array(GRID_HEIGHT)
            .fill()
            .map(() => Array(GRID_WIDTH).fill(null));
          const usedColors = new Set();
          const initialRows = Math.min(
            6 + Math.floor((currentLevel - 1) / 2),
            GRID_HEIGHT - 2
          );
          for (let row = 0; row < initialRows; row++) {
            const isOddRow = row % 2 === 1;
            const numBubbles = isOddRow ? 7 : 8;
            for (let col = 0; col < numBubbles; col++) {
              const color =
                ALL_COLORS[Math.floor(Math.random() * ALL_COLORS.length)];
              grid[row][col] = color;
              usedColors.add(color);
            }
          }
          COLORS = Array.from(usedColors);
          nextBubbles = [getRandomColor(), getExistingColor()];
          spawnBubble();
          totalScore = 0;
          currentLevel = 1;
          gameOver = false;
          gameStarted = true;
          particles = [];
          canShoot = true;
          levelStartTime = performance.now();
          shotCount = 0;
          ceilingOffset = 0;
          abilityAvailable = true;
          lastAbilityUse = 0;
          abilityCooldown = 0;
          speechBubble = null;
          if (characterSelectScreen)
            characterSelectScreen.style.display = "none";
          showLevelScreen();
          updateUI();
          initAudioContext();
          playBgm();

          if (window.FarcadeSDK) {
            window.FarcadeSDK.singlePlayer.actions.ready();
          }
        } catch (error) {
          console.error("Game init error:", error);
        }
      }

      // Get random color
      function getRandomColor() {
        return (
          COLORS[Math.floor(Math.random() * COLORS.length)] || ALL_COLORS[0]
        );
      }

      // Get existing color
      function getExistingColor() {
        const existingColors = new Set();
        for (let row = 0; row < GRID_HEIGHT; row++) {
          for (let col = 0; col < GRID_WIDTH; col++) {
            if (grid[row][col]) existingColors.add(grid[row][col]);
          }
        }
        const availableColors = Array.from(existingColors);
        return (
          availableColors[Math.floor(Math.random() * availableColors.length)] ||
          ALL_COLORS[0]
        );
      }

      // Spawn bubble
      function spawnBubble() {
        try {
          currentBubble = {
            x: canvas.width / 2,
            y: canvas.height - 20,
            color: nextBubbles.shift(),
            velocity: { x: 0, y: 0 },
            moving: false,
            isSpecial: false,
            isWild: false,
          };
          nextBubbles.push(getExistingColor());
          canShoot = true;
          updateUI();
        } catch (error) {
          console.error("Spawn bubble error:", error);
        }
      }

      // Snap bubble to grid
      function snapBubbleToGrid(bubble) {
        try {
          if (!bubble) return;
          let pos = getGridPos(bubble.x, bubble.y);
          const isOddRow = pos.row % 2 === 1;
          const maxCols = isOddRow ? GRID_WIDTH - 1 : GRID_WIDTH;

          if (grid[pos.row][pos.col] || pos.col >= maxCols || pos.col < 0) {
            const emptyPos = findNearestEmptySpot(pos.row, pos.col, bubble);
            if (emptyPos) {
              pos = emptyPos;
            } else {
              for (let r = Math.max(0, pos.row - 1); r < GRID_HEIGHT; r++) {
                const rMaxCols = r % 2 === 1 ? GRID_WIDTH - 1 : GRID_WIDTH;
                for (let c = 0; c < rMaxCols; c++) {
                  if (!grid[r][c] && (r === 0 || hasAdjacentBubble(r, c))) {
                    pos = { row: r, col: c };
                    break;
                  }
                }
                if (
                  pos.row === r &&
                  (r === 0 || hasAdjacentBubble(pos.row, pos.col))
                )
                  break;
              }
            }
          }

          if (pos.row !== 0 && !hasAdjacentBubble(pos.row, pos.col)) {
            for (
              let r = Math.max(0, pos.row - 1);
              r <= Math.min(GRID_HEIGHT - 1, pos.row + 1);
              r++
            ) {
              const rMaxCols = r % 2 === 1 ? GRID_WIDTH - 1 : GRID_WIDTH;
              for (let c = 0; c < rMaxCols; c++) {
                if (!grid[r][c] && (r === 0 || hasAdjacentBubble(r, c))) {
                  pos = { row: r, col: c };
                  break;
                }
              }
              if (
                pos.row === r &&
                (r === 0 || hasAdjacentBubble(pos.row, pos.col))
              )
                break;
            }
          }

          if (bubble.isSpecial) {
            // Toshi's Neon Blue Special Bubble
            let targetColor = null;
            // Check adjacent bubbles for color
            const neighbors = [
              { row: pos.row - 1, col: pos.col },
              { row: pos.row + 1, col: pos.col },
              { row: pos.row, col: pos.col - 1 },
              { row: pos.row, col: pos.col + 1 },
              { row: pos.row - 1, col: isOddRow ? pos.col + 1 : pos.col - 1 },
              { row: pos.row + 1, col: isOddRow ? pos.col + 1 : pos.col - 1 },
            ];
            for (let n of neighbors) {
              if (
                n.row >= 0 &&
                n.row < GRID_HEIGHT &&
                n.col >= 0 &&
                n.col < (n.row % 2 === 1 ? GRID_WIDTH - 1 : GRID_WIDTH) &&
                grid[n.row][n.col]
              ) {
                targetColor = grid[n.row][n.col];
                break;
              }
            }
            // If no adjacent bubble, use the color at the position (if any)
            if (!targetColor && grid[pos.row][pos.col]) {
              targetColor = grid[pos.row][pos.col];
            }
            if (targetColor) {
              // Remove all bubbles of the target color
              for (let row = 0; row < GRID_HEIGHT; row++) {
                for (let col = 0; col < GRID_WIDTH; col++) {
                  if (grid[row][col] === targetColor) {
                    createParticles(row, col, NEON_BLUE, true); // Neon effect
                    grid[row][col] = null;
                  }
                }
              }
              removeFloatingBubbles();
            }
            // Create neon particles at impact
            createParticles(pos.row, pos.col, NEON_BLUE, true);
          } else if (bubble.isWild) {
            // Mochi's Wild Bubble
            grid[pos.row][pos.col] = bubble.color; // Place the bubble
            // Find all adjacent colors
            const adjacentColors = new Set();
            const neighbors = [
              { row: pos.row - 1, col: pos.col },
              { row: pos.row + 1, col: pos.col },
              { row: pos.row, col: pos.col - 1 },
              { row: pos.row, col: pos.col + 1 },
              { row: pos.row - 1, col: isOddRow ? pos.col + 1 : pos.col - 1 },
              { row: pos.row + 1, col: isOddRow ? pos.col + 1 : pos.col - 1 },
            ];
            for (let n of neighbors) {
              if (
                n.row >= 0 &&
                n.row < GRID_HEIGHT &&
                n.col >= 0 &&
                n.col < (n.row % 2 === 1 ? GRID_WIDTH - 1 : GRID_WIDTH) &&
                grid[n.row][n.col]
              ) {
                adjacentColors.add(grid[n.row][n.col]);
              }
            }
            // Check matches for each adjacent color
            let totalMatches = [];
            for (let color of adjacentColors) {
              grid[pos.row][pos.col] = color; // Temporarily set to this color
              const matches = checkMatches(pos.row, pos.col);
              if (matches.length >= 3) {
                totalMatches.push(...matches);
              }
            }
            if (totalMatches.length >= 3) {
              totalMatches.forEach(({ row, col }) => {
                createParticles(row, col, grid[row][col]);
                grid[row][col] = null;
              });
              removeFloatingBubbles();
            } else {
              grid[pos.row][pos.col] = getRandomColor(); // Place a random color if no match
            }
          } else {
            // Normal bubble
            grid[pos.row][pos.col] = bubble.color;
            checkAndRemoveMatches(pos.row, pos.col);
          }

          if (window.FarcadeSDK) {
            window.FarcadeSDK.singlePlayer.actions.hapticFeedback();
          }
          currentBubble = null;

          // Check if ceiling should drop
          const shotsPerCeilingDrop = Math.max(
            3,
            BASE_SHOTS_PER_CEILING_DROP - Math.floor(currentLevel / 2)
          );
          if (shotCount >= shotsPerCeilingDrop) {
            lowerCeiling();
            shotCount = 0;
          }

          if (isGridEmpty()) {
            const timeElapsed = (performance.now() - levelStartTime) / 1000; // In seconds
            const levelScore = BASE_SCORE_PER_LEVEL * currentLevel;
            const timeBonus = Math.max(
              0,
              MAX_TIME_BONUS - timeElapsed * TIME_BONUS_DECREASE
            );
            totalScore += Math.floor(levelScore + timeBonus);
            currentLevel++;
            grid = Array(GRID_HEIGHT)
              .fill()
              .map(() => Array(GRID_WIDTH).fill(null));
            const usedColors = new Set();
            const initialRows = Math.min(
              6 + Math.floor((currentLevel - 1) / 2),
              GRID_HEIGHT - 2
            );
            for (let row = 0; row < initialRows; row++) {
              const isOddRow = row % 2 === 1;
              const numBubbles = isOddRow ? 7 : 8;
              for (let col = 0; col < numBubbles; col++) {
                const color =
                  ALL_COLORS[Math.floor(Math.random() * ALL_COLORS.length)];
                grid[row][col] = color;
                usedColors.add(color);
              }
            }
            COLORS = Array.from(usedColors);
            nextBubbles = [getRandomColor(), getExistingColor()];
            spawnBubble();
            shotCount = 0; // Reset shot counter
            ceilingOffset = 0; // Reset ceiling offset
            showLevelScreen();
            updateUI();
          } else {
            spawnBubble();
          }
        } catch (error) {
          console.error("Snap bubble error:", error);
        }
      }

      // Check if grid is empty
      function isGridEmpty() {
        try {
          for (let row = 0; row < GRID_HEIGHT; row++) {
            for (let col = 0; col < GRID_WIDTH; col++) {
              if (grid[row][col]) return false;
            }
          }
          return true;
        } catch (error) {
          console.error("Grid empty check error:", error);
          return false;
        }
      }

      // Grid position calculations
      function getGridPos(x, y) {
        try {
          const row = Math.floor(
            (y - ceilingOffset) / ((BUBBLE_SIZE * Math.sqrt(3)) / 2)
          );
          const isOddRow = row % 2 === 1;
          const colOffset = isOddRow ? BUBBLE_SIZE / 2 : 0;
          const col = Math.floor((x - colOffset) / BUBBLE_SIZE);
          return {
            row: Math.max(0, Math.min(GRID_HEIGHT - 1, row)),
            col: Math.max(
              0,
              Math.min(isOddRow ? GRID_WIDTH - 1 : GRID_WIDTH - 1, col)
            ),
          };
        } catch (error) {
          console.error("Get grid pos error:", error);
          return { row: 0, col: 0 };
        }
      }

      // Shooting mechanics
      function shootBubble() {
        try {
          if (currentBubble && !currentBubble.moving && canShoot) {
            currentBubble.velocity = {
              x: Math.cos(launcherAngle) * 10,
              y: -Math.sin(launcherAngle) * 10,
            };
            currentBubble.moving = true;
            canShoot = false;
            shotCount++; // Increment shot counter
            if (window.FarcadeSDK) {
              window.FarcadeSDK.singlePlayer.actions.hapticFeedback();
            }
          }
        } catch (error) {
          console.error("Shoot bubble error:", error);
        }
      }

      // Activate ability
      function activateAbility() {
        try {
          if (abilityAvailable && gameStarted && !gameOver && currentBubble) {
            if (selectedCharacter === "Toshi") {
              // Neon Blue Special Bubble
              currentBubble.color = NEON_BLUE;
              currentBubble.isSpecial = true;
              currentBubble.isWild = false;
              abilityCooldown = ABILITY_COOLDOWN_TOSHI;
            } else if (selectedCharacter === "Mochi") {
              // Wild Bubble
              currentBubble.isWild = true;
              currentBubble.isSpecial = false;
              abilityCooldown = ABILITY_COOLDOWN_MOCHI;
            }
            abilityAvailable = false;
            lastAbilityUse = performance.now();
            speechBubble = {
              text: "Skill activated!",
              duration: SPEECH_BUBBLE_DURATION,
              opacity: 0,
            };
            if (window.FarcadeSDK) {
              window.FarcadeSDK.singlePlayer.actions.hapticFeedback();
            }
          }
        } catch (error) {
          console.error("Activate ability error:", error);
        }
      }

      // Create particles (modified for neon effect)
      function createParticles(row, col, color, isNeon = false) {
        try {
          const particleCount = isNeon ? 15 : isMobile ? 5 : 10;
          const offset = row % 2 === 1 ? BUBBLE_SIZE / 2 : 0;
          for (let i = 0; i < particleCount; i++) {
            particles.push({
              x: col * BUBBLE_SIZE + offset + BUBBLE_SIZE / 2,
              y: row * ((BUBBLE_SIZE * Math.sqrt(3)) / 2) + ceilingOffset,
              vx: (Math.random() - 0.5) * (isNeon ? 8 : 6),
              vy: (Math.random() - 0.5) * (isNeon ? 8 : 6),
              size: Math.random() * (isNeon ? 8 : 6) + (isNeon ? 4 : 2),
              color: color,
              life: isNeon ? 40 : 30,
            });
          }
          if (particles.length > 100) {
            particles = particles.slice(-100);
          }
        } catch (error) {
          console.error("Create particles error:", error);
        }
      }

      // Find nearest empty spot
      function findNearestEmptySpot(row, col, bubble) {
        try {
          const candidates = [];
          const bubbleX = bubble.x;
          const bubbleY = bubble.y - ceilingOffset; // Adjust for ceiling offset

          for (
            let r = Math.max(0, row - 1);
            r <= Math.min(GRID_HEIGHT - 1, row + 1);
            r++
          ) {
            const rMaxCols = r % 2 === 1 ? GRID_WIDTH - 1 : GRID_WIDTH;
            for (let c = 0; c < rMaxCols; c++) {
              if (!grid[r][c] && (r === 0 || hasAdjacentBubble(r, c))) {
                const offset = r % 2 === 1 ? BUBBLE_SIZE / 2 : 0;
                const nx = c * BUBBLE_SIZE + offset + BUBBLE_SIZE / 2;
                const ny =
                  r * ((BUBBLE_SIZE * Math.sqrt(3)) / 2) + BUBBLE_SIZE / 2;
                const dist = Math.hypot(nx - bubbleX, ny - bubbleY);
                candidates.push({ row: r, col: c, dist });
              }
            }
          }

          if (candidates.length === 0) return null;

          candidates.sort((a, b) => {
            if (Math.abs(a.dist - b.dist) < 0.01) {
              return Math.random() < 0.5 ? -1 : 1;
            }
            return a.dist - b.dist;
          });

          return candidates[0];
        } catch (error) {
          console.error("Find empty spot error:", error);
          return null;
        }
      }

      // Check adjacent bubble
      function hasAdjacentBubble(row, col) {
        try {
          const isOddRow = row % 2 === 1;
          const maxCols = isOddRow ? GRID_WIDTH - 1 : GRID_WIDTH;
          const neighbors = [
            { row: row - 1, col: col },
            { row: row + 1, col: col },
            { row: row, col: col - 1 },
            { row: row, col: col + 1 },
            { row: row - 1, col: isOddRow ? col + 1 : col - 1 },
            { row: row + 1, col: isOddRow ? col + 1 : col - 1 },
          ];

          for (let n of neighbors) {
            if (
              n.row >= 0 &&
              n.row < GRID_HEIGHT &&
              n.col >= 0 &&
              n.col < (n.row % 2 === 1 ? GRID_WIDTH - 1 : GRID_WIDTH) &&
              grid[n.row][n.col]
            ) {
              return true;
            }
          }
          return false;
        } catch (error) {
          console.error("Has adjacent bubble error:", error);
          return false;
        }
      }

      // Check and remove matches
      function checkAndRemoveMatches(row, col) {
        try {
          if (!grid[row][col]) return;
          const matches = checkMatches(row, col);
          if (matches.length >= 3) {
            matches.forEach(({ row, col }) => {
              createParticles(row, col, grid[row][col]);
              grid[row][col] = null;
            });
            if (matches.length >= 8) {
              // Show speech bubble for large matches
              speechBubble = {
                text: largeMatchMessages[
                  Math.floor(Math.random() * largeMatchMessages.length)
                ],
                duration: SPEECH_BUBBLE_DURATION,
                opacity: 0,
              };
            }
            if (window.FarcadeSDK) {
              window.FarcadeSDK.singlePlayer.actions.hapticFeedback();
            }
            removeFloatingBubbles();
          }
        } catch (error) {
          console.error("Check matches error:", error);
        }
      }

      // Match checking
      function checkMatches(row, col) {
        try {
          const color = grid[row][col];
          const visited = new Set();
          const toCheck = [{ row, col }];
          const matches = [];

          while (toCheck.length) {
            const { row: r, col: c } = toCheck.pop();
            const key = `${r},${c}`;
            const isOddRow = r % 2 === 1;
            if (
              visited.has(key) ||
              r < 0 ||
              r >= GRID_HEIGHT ||
              c < 0 ||
              c >= GRID_WIDTH ||
              grid[r] === undefined ||
              grid[r][c] !== color
            )
              continue;

            visited.add(key);
            matches.push({ row: r, col: c });

            const neighbors = [
              { row: r - 1, col: c },
              { row: r + 1, col: c },
              { row: r, col: c - 1 },
              { row: r, col: c + 1 },
              { row: r - 1, col: isOddRow ? c + 1 : c - 1 },
              { row: r + 1, col: isOddRow ? c + 1 : c - 1 },
            ];
            toCheck.push(...neighbors);
          }
          return matches;
        } catch (error) {
          console.error("Match checking error:", error);
          return [];
        }
      }

      // Remove floating bubbles
      function removeFloatingBubbles() {
        try {
          const connected = new Set();
          const toCheck = [];

          // Start from bubbles in row 0 (connected to ceiling)
          for (let col = 0; col < GRID_WIDTH; col++) {
            if (grid[0][col]) {
              toCheck.push({ row: 0, col });
            }
          }

          // BFS to find all connected bubbles
          while (toCheck.length > 0) {
            const { row, col } = toCheck.shift();
            const key = `${row},${col}`;
            if (connected.has(key) || !grid[row][col]) continue;

            connected.add(key);

            const isOddRow = row % 2 === 1;
            const neighbors = [
              { row: row - 1, col: col }, // Up
              { row: row + 1, col: col }, // Down
              { row: row, col: col - 1 }, // Left
              { row: row, col: col + 1 }, // Right
              { row: row - 1, col: isOddRow ? col + 1 : col - 1 }, // Diagonal up
              { row: row + 1, col: isOddRow ? col + 1 : col - 1 }, // Diagonal down
            ];

            for (let n of neighbors) {
              if (
                n.row >= 0 &&
                n.row < GRID_HEIGHT &&
                n.col >= 0 &&
                n.col < (n.row % 2 === 1 ? GRID_WIDTH - 1 : GRID_WIDTH) &&
                grid[n.row][n.col] &&
                !connected.has(`${n.row},${n.col}`)
              ) {
                toCheck.push(n);
              }
            }
          }

          // Remove unconnected bubbles
          let removed = false;
          for (let row = 0; row < GRID_HEIGHT; row++) {
            const maxCols = row % 2 === 1 ? GRID_WIDTH - 1 : GRID_WIDTH;
            for (let col = 0; col < maxCols; col++) {
              if (grid[row][col] && !connected.has(`${row},${col}`)) {
                createParticles(row, col, grid[row][col]);
                grid[row][col] = null;
                removed = true;
              }
            }
          }

          // If bubbles were removed, check again for new floating bubbles
          if (removed) {
            removeFloatingBubbles();
          }
        } catch (error) {
          console.error("Remove floating bubbles error:", error);
        }
      }

      // Calculate trajectory
      function calculateTrajectoryAndCollision() {
        try {
          const launcherX = canvas.width / 2;
          const launcherY = canvas.height - 20;
          let x = launcherX;
          let y = launcherY;
          let vx = Math.cos(launcherAngle) * 5;
          let vy = -Math.sin(launcherAngle) * 5;
          const points = [];
          let collisionX, collisionY;

          while (y > 0) {
            points.push({ x, y });

            x += vx;
            y += vy;

            if (x < BUBBLE_SIZE / 2 || x > canvas.width - BUBBLE_SIZE / 2) {
              vx *= -1;
              x = Math.max(
                BUBBLE_SIZE / 2,
                Math.min(canvas.width - BUBBLE_SIZE / 2, x)
              );
            }

            const pos = getGridPos(x, y);
            for (
              let row = Math.max(0, pos.row - 1);
              row <= Math.min(GRID_HEIGHT - 1, pos.row + 1);
              row++
            ) {
              for (let col = 0; col < GRID_WIDTH; col++) {
                if (grid[row][col]) {
                  const offset = row % 2 === 1 ? BUBBLE_SIZE / 2 : 0;
                  const bubbleX = col * BUBBLE_SIZE + offset + BUBBLE_SIZE / 2;
                  const bubbleY =
                    row * ((BUBBLE_SIZE * Math.sqrt(3)) / 2) +
                    BUBBLE_SIZE / 2 +
                    ceilingOffset;
                  if (
                    Math.hypot(x - bubbleX, y - bubbleY) <
                    BUBBLE_SIZE * 0.9
                  ) {
                    collisionX = x;
                    collisionY = y;
                    points.push({ x: collisionX, y: collisionY });
                    return { points, collisionX, collisionY };
                  }
                }
              }
            }

            if (y < BUBBLE_SIZE / 2 + ceilingOffset) {
              collisionX = x;
              collisionY = y;
              points.push({ x: collisionX, y: collisionY });
              return { points, collisionX, collisionY };
            }
          }
          collisionX = x;
          collisionY = y;
          points.push({ x: collisionX, y: collisionY });
          return { points, collisionX, collisionY };
        } catch (error) {
          console.error("Calculate trajectory error:", error);
          return { points: [], collisionX: 0, collisionY: 0 };
        }
      }

      // Update game state
      function update() {
        try {
          if (!gameStarted || gameOver) return;

          if (currentBubble && currentBubble.moving) {
            currentBubble.x += currentBubble.velocity.x;
            currentBubble.y += currentBubble.velocity.y;

            if (
              currentBubble.x < BUBBLE_SIZE / 2 ||
              currentBubble.x > canvas.width - BUBBLE_SIZE / 2
            ) {
              currentBubble.velocity.x *= -1;
              currentBubble.x = Math.max(
                BUBBLE_SIZE / 2,
                Math.min(canvas.width - BUBBLE_SIZE / 2, currentBubble.x)
              );
            }

            if (currentBubble.y < BUBBLE_SIZE / 2 + ceilingOffset) {
              currentBubble.moving = false;
              snapBubbleToGrid(currentBubble);
              return;
            }

            const pos = getGridPos(currentBubble.x, currentBubble.y);
            for (
              let row = Math.max(0, pos.row - 1);
              row <= Math.min(GRID_HEIGHT - 1, pos.row + 1);
              row++
            ) {
              for (let col = 0; col < GRID_WIDTH; col++) {
                if (grid[row][col]) {
                  const offset = row % 2 === 1 ? BUBBLE_SIZE / 2 : 0;
                  const bubbleX = col * BUBBLE_SIZE + offset + BUBBLE_SIZE / 2;
                  const bubbleY =
                    row * ((BUBBLE_SIZE * Math.sqrt(3)) / 2) +
                    BUBBLE_SIZE / 2 +
                    ceilingOffset;
                  if (
                    Math.hypot(
                      currentBubble.x - bubbleX,
                      currentBubble.y - bubbleY
                    ) <
                    BUBBLE_SIZE * 0.9
                  ) {
                    currentBubble.moving = false;
                    snapBubbleToGrid(currentBubble);
                    return;
                  }
                }
              }
            }
          }

          if (keysPressed.left) launcherAngle += 0.01;
          if (keysPressed.right) launcherAngle -= 0.01;
          launcherAngle = Math.max(
            Math.PI / 2 - 1.4835,
            Math.min(Math.PI / 2 + 1.4835, launcherAngle)
          );

          keyPressedThisFrame.left = false;
          keyPressedThisFrame.right = false;

          particles = particles.filter((p) => p?.life > 0);
          particles.forEach((p) => {
            if (p) {
              p.x += p.vx;
              p.y += p.vy;
              p.vy += 0.1;
              p.life--;
              p.size *= 0.95;
            }
          });

          // Update ability cooldown
          if (!abilityAvailable) {
            const now = performance.now();
            const cooldown =
              selectedCharacter === "Toshi"
                ? ABILITY_COOLDOWN_TOSHI
                : ABILITY_COOLDOWN_MOCHI;
            abilityCooldown = Math.max(0, cooldown - (now - lastAbilityUse));
            if (abilityCooldown <= 0) {
              abilityAvailable = true;
            }
          }

          // Update speech bubble
          if (speechBubble) {
            speechBubble.duration -= 16; // Approx 60 FPS
            // Fade-in (0 to 0.5s)
            if (speechBubble.duration > SPEECH_BUBBLE_DURATION - 500) {
              const progress =
                (SPEECH_BUBBLE_DURATION - speechBubble.duration) / 500;
              speechBubble.opacity = progress;
            }
            // Fade-out (1.5s to 2s)
            else if (speechBubble.duration < 500) {
              speechBubble.opacity = speechBubble.duration / 500;
            } else {
              speechBubble.opacity = 1;
            }
            if (speechBubble.duration <= 0) {
              speechBubble = null;
            }
          }

          updateUI();

          // Check for game over considering ceilingOffset
          for (let row = 0; row < GRID_HEIGHT; row++) {
            for (let col = 0; col < GRID_WIDTH; col++) {
              if (
                grid[row][col] &&
                row * ((BUBBLE_SIZE * Math.sqrt(3)) / 2) +
                  BUBBLE_SIZE +
                  ceilingOffset >=
                  LIMIT_LINE_Y
              ) {
                gameOver = true;
                if (window.FarcadeSDK) {
                  window.FarcadeSDK.singlePlayer.actions.gameOver({
                    score: Math.floor(totalScore),
                  });
                }
                cleanupAudio();
                return;
              }
            }
          }
        } catch (error) {
          console.error("Update error:", error);
        }
      }

      // Render game
      function draw() {
        try {
          if (!ctx) return;
          ctx.clearRect(0, 0, canvas.width, canvas.height);

          if (gameStarted) {
            // Draw dark ceiling area
            ctx.beginPath();
            ctx.rect(0, 0, canvas.width, ceilingOffset);
            ctx.fillStyle = "rgba(20, 20, 20, 1)"; // Fully opaque dark color
            ctx.fill();

            for (let y = 0; y < GRID_HEIGHT; y++) {
              for (let x = 0; x < GRID_WIDTH; x++) {
                if (grid[y][x]) {
                  const offset = y % 2 === 1 ? BUBBLE_SIZE / 2 : 0;
                  const bubbleX = x * BUBBLE_SIZE + offset;
                  const bubbleY =
                    y * ((BUBBLE_SIZE * Math.sqrt(3)) / 2) + ceilingOffset;
                  ctx.beginPath();
                  ctx.arc(
                    bubbleX + BUBBLE_SIZE / 2,
                    bubbleY + BUBBLE_SIZE / 2,
                    BUBBLE_SIZE / 2 - 2,
                    0,
                    Math.PI * 2
                  );
                  ctx.fillStyle = grid[y][x];
                  ctx.fill();
                  ctx.strokeStyle = "#fff";
                  ctx.lineWidth = 2;
                  ctx.stroke();
                }
              }
            }

            if (currentBubble) {
              ctx.beginPath();
              ctx.arc(
                currentBubble.x,
                currentBubble.y,
                BUBBLE_SIZE / 2 - 2,
                0,
                Math.PI * 2
              );
              if (currentBubble.isWild) {
                // Cycle colors for wild bubble
                const colorIndex =
                  Math.floor(performance.now() / 200) % ALL_COLORS.length;
                ctx.fillStyle = ALL_COLORS[colorIndex];
              } else {
                ctx.fillStyle = currentBubble.color;
              }
              ctx.fill();
              ctx.strokeStyle = "#fff";
              ctx.stroke();
            }

            const launcherX = canvas.width / 2;
            const launcherY = canvas.height - 20;
            const circleRadius = isMobile ? 30 : 40;
            const arrowLength = isMobile ? 60 : 80;

            ctx.beginPath();
            ctx.arc(launcherX, launcherY, circleRadius, 0, Math.PI * 2);
            ctx.strokeStyle = "#ff0066";
            ctx.lineWidth = 2;
            ctx.stroke();

            const arrowStartX = launcherX;
            const arrowStartY = launcherY;
            const arrowEndX =
              arrowStartX + Math.cos(launcherAngle) * arrowLength;
            const arrowEndY =
              arrowStartY - Math.sin(launcherAngle) * arrowLength;

            ctx.beginPath();
            ctx.moveTo(arrowStartX, arrowStartY);
            ctx.lineTo(arrowEndX, arrowEndY);
            ctx.strokeStyle = "#ff0066";
            ctx.lineWidth = 4;
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(arrowEndX, arrowEndY);
            ctx.lineTo(
              arrowEndX - Math.cos(launcherAngle + Math.PI / 6) * 15,
              arrowEndY + Math.sin(launcherAngle + Math.PI / 6) * 15
            );
            ctx.moveTo(arrowEndX, arrowEndY);
            ctx.lineTo(
              arrowEndX - Math.cos(launcherAngle - Math.PI / 6) * 15,
              arrowEndY + Math.sin(launcherAngle - Math.PI / 6) * 15
            );
            ctx.stroke();

            if (currentBubble && !currentBubble.moving) {
              const { points, collisionX, collisionY } =
                calculateTrajectoryAndCollision();
              points.forEach((point, i) => {
                if (i % 4 === 0) {
                  ctx.beginPath();
                  ctx.arc(point.x, point.y, 2, 0, Math.PI * 2);
                  ctx.fillStyle = "#00ffcc";
                  ctx.fill();
                }
              });
              ctx.beginPath();
              ctx.arc(collisionX, collisionY, 4, 0, Math.PI * 2);
              ctx.fillStyle = "#ff0066";
              ctx.fill();
            }

            particles.forEach((p) => {
              if (p) {
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fillStyle = p.color;
                ctx.fill();
              }
            });

            ctx.beginPath();
            ctx.moveTo(0, LIMIT_LINE_Y);
            ctx.lineTo(canvas.width, LIMIT_LINE_Y);
            ctx.strokeStyle = "#ff0066";
            ctx.lineWidth = 2;
            ctx.stroke();

            // Draw selected character image
            if (selectedCharacter && characterImages[selectedCharacter]) {
              ctx.drawImage(
                characterImages[selectedCharacter],
                60, // Moved right
                canvas.height - 100, // Aligned to bottom
                100, // Larger size
                100
              );
            }

            // Draw speech bubble (text box with border radius and fade animation)
            if (speechBubble) {
              const boxX = 60 + 50; // Center above character
              const boxY = canvas.height - 100 - 20; // Above character
              const boxWidth = 200;
              const boxHeight = 50;
              const borderRadius = 8;

              ctx.save();
              ctx.globalAlpha = speechBubble.opacity;

              // Draw rounded rectangle
              ctx.beginPath();
              ctx.moveTo(
                boxX - boxWidth / 2 + borderRadius,
                boxY - boxHeight / 2
              );
              ctx.lineTo(
                boxX + boxWidth / 2 - borderRadius,
                boxY - boxHeight / 2
              );
              ctx.arcTo(
                boxX + boxWidth / 2,
                boxY - boxHeight / 2,
                boxX + boxWidth / 2,
                boxY - boxHeight / 2 + borderRadius,
                borderRadius
              );
              ctx.lineTo(
                boxX + boxWidth / 2,
                boxY + boxHeight / 2 - borderRadius
              );
              ctx.arcTo(
                boxX + boxWidth / 2,
                boxY + boxHeight / 2,
                boxX + boxWidth / 2 - borderRadius,
                boxY + boxHeight / 2,
                borderRadius
              );
              ctx.lineTo(
                boxX - boxWidth / 2 + borderRadius,
                boxY + boxHeight / 2
              );
              ctx.arcTo(
                boxX - boxWidth / 2,
                boxY + boxHeight / 2,
                boxX - boxWidth / 2,
                boxY + boxHeight / 2 - borderRadius,
                borderRadius
              );
              ctx.lineTo(
                boxX - boxWidth / 2,
                boxY - boxHeight / 2 + borderRadius
              );
              ctx.arcTo(
                boxX - boxWidth / 2,
                boxY - boxHeight / 2,
                boxX - boxWidth / 2 + borderRadius,
                boxY - boxHeight / 2,
                borderRadius
              );
              ctx.closePath();
              ctx.fillStyle = "#ffffff";
              ctx.fill();
              ctx.strokeStyle = "#000000";
              ctx.lineWidth = 2;
              ctx.stroke();

              // Draw text
              ctx.fillStyle = "#000000";
              ctx.font = "18px Courier New";
              ctx.textAlign = "center";
              ctx.textBaseline = "middle";
              ctx.fillText(speechBubble.text, boxX, boxY);

              ctx.restore();
            }

            // Draw ability button
            if (selectedCharacter) {
              const buttonX = canvas.width * 0.75 - 25; // Between launcher and next-bubbles
              const buttonY = (canvas.height + LIMIT_LINE_Y) / 2; // Halfway between bottom and game over line
              const buttonRadius = 30;

              ctx.save();
              ctx.shadowColor = abilityAvailable
                ? NEON_BLUE
                : "rgba(20, 20, 20, 1)";
              ctx.shadowBlur = abilityAvailable ? 10 : 5;
              ctx.beginPath();
              ctx.arc(buttonX, buttonY, buttonRadius, 0, Math.PI * 2);
              ctx.fillStyle = abilityAvailable
                ? NEON_BLUE
                : "rgba(20, 20, 20, 1)";
              ctx.fill();
              ctx.strokeStyle = "#fff";
              ctx.lineWidth = 2;
              ctx.stroke();
              ctx.restore();

              ctx.fillStyle = "#ffffff"; // White text
              ctx.font = "16px Courier New";
              ctx.textAlign = "center";
              ctx.textBaseline = "middle";
              if (abilityAvailable) {
                ctx.fillText("ON", buttonX, buttonY);
              } else {
                const secondsLeft = Math.ceil(abilityCooldown / 1000);
                ctx.fillText(`${secondsLeft}s`, buttonX, buttonY);
              }
            }
          }
        } catch (error) {
          console.error("Draw error:", error);
        }
      }

      // Update UI
      function updateUI() {
        try {
          if (scoreDisplay)
            scoreDisplay.textContent = `Score: ${Math.floor(totalScore)}`;
          if (levelDisplay) levelDisplay.textContent = `Level: ${currentLevel}`;
          if (timeDisplay && gameStarted) {
            const timeElapsed = Math.floor(
              (performance.now() - levelStartTime) / 1000
            );
            timeDisplay.textContent = `Time: ${timeElapsed}s`;
          }
          if (instructions) {
            instructions.textContent = isMobile
              ? "Hold and move to aim, release to shoot. Tap the button to activate your Skill."
              : "Use Left/Right Arrow to aim, Space to shoot, and Enter to activate your Skill.";
          }
          if (next1) next1.style.backgroundColor = nextBubbles[0] || "#ffffff";
          if (next2) next2.style.backgroundColor = nextBubbles[1] || "#ffffff";
        } catch (error) {
          console.error("Update UI error:", error);
        }
      }

      // Game loop
      function gameLoop() {
        try {
          update();
          draw();
          requestAnimationFrame(gameLoop);
        } catch (error) {
          console.error("Game loop error:", error);
        }
      }

      // Unified input handling
      function handleInputStart(x, y, isTouch = false) {
        try {
          if (gameStarted && !gameOver) {
            // Check if ability button was clicked
            const buttonX = canvas.width * 0.75 - 25;
            const buttonY = (canvas.height + LIMIT_LINE_Y) / 2;
            const buttonRadius = 30;
            if (
              Math.hypot(x - buttonX, y - buttonY) < buttonRadius &&
              abilityAvailable
            ) {
              activateAbility();
              return;
            }

            // Normal shooting input
            touchStartX = x;
            if (isTouch) initAudioContext();
          }
        } catch (error) {
          console.error("Input start error:", error);
        }
      }

      function handleInputMove(x) {
        try {
          if (gameStarted && !gameOver && touchStartX !== null) {
            const deltaX = x - touchStartX;
            launcherAngle -= deltaX * (isMobile ? 0.003 : 0.005);
            launcherAngle = Math.max(
              Math.PI / 2 - 1.4835,
              Math.min(Math.PI / 2 + 1.4835, launcherAngle)
            );
            touchStartX = x;
          }
        } catch (error) {
          console.error("Input move error:", error);
        }
      }

      function handleInputEnd() {
        try {
          if (gameStarted && !gameOver && touchStartX !== null) {
            shootBubble();
            touchStartX = null;
          }
        } catch (error) {
          console.error("Input end error:", error);
        }
      }

      // Event listeners
      if (canvas) {
        canvas.addEventListener(
          "touchstart",
          (e) => {
            e.preventDefault();
            if (e.touches[0]) {
              const rect = canvas.getBoundingClientRect();
              const scaleX = canvas.width / rect.width;
              const scaleY = canvas.height / rect.height;
              handleInputStart(
                (e.touches[0].clientX - rect.left) * scaleX,
                (e.touches[0].clientY - rect.top) * scaleY,
                true
              );
            }
          },
          { passive: false }
        );

        canvas.addEventListener(
          "touchmove",
          (e) => {
            e.preventDefault();
            if (e.touches[0]) {
              const rect = canvas.getBoundingClientRect();
              const scaleX = canvas.width / rect.width;
              handleInputMove((e.touches[0].clientX - rect.left) * scaleX);
            }
          },
          { passive: false }
        );

        canvas.addEventListener(
          "touchend",
          (e) => {
            e.preventDefault();
            handleInputEnd();
          },
          { passive: false }
        );

        canvas.addEventListener("mousedown", (e) => {
          e.preventDefault();
          const rect = canvas.getBoundingClientRect();
          const scaleX = canvas.width / rect.width;
          const scaleY = canvas.height / rect.height;
          handleInputStart(
            (e.clientX - rect.left) * scaleX,
            (e.clientY - rect.top) * scaleY
          );
        });

        canvas.addEventListener("mousemove", (e) => {
          if (touchStartX !== null) {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            handleInputMove((e.clientX - rect.left) * scaleX);
          }
        });

        canvas.addEventListener("mouseup", (e) => {
          e.preventDefault();
          handleInputEnd();
        });

        canvas.addEventListener("contextmenu", (e) => e.preventDefault());
      }

      // Keyboard input
      document.addEventListener("keydown", (e) => {
        try {
          if (gameStarted && !gameOver) {
            if (e.key === "ArrowLeft" && !keysPressed.left) {
              keysPressed.left = true;
              keyPressedThisFrame.left = true;
              launcherAngle += 0.002;
            }
            if (e.key === "ArrowRight" && !keysPressed.right) {
              keysPressed.right = true;
              keyPressedThisFrame.right = true;
              launcherAngle -= 0.002;
            }
            if (e.key === " ") {
              e.preventDefault();
              shootBubble();
            }
            if (e.key === "Enter" && abilityAvailable) {
              activateAbility();
            }
            launcherAngle = Math.max(
              Math.PI / 2 - 1.4835,
              Math.min(Math.PI / 2 + 1.4835, launcherAngle)
            );
          }
        } catch (error) {
          console.error("Keydown error:", error);
        }
      });

      document.addEventListener("keyup", (e) => {
        try {
          if (e.key === "ArrowLeft") keysPressed.left = false;
          if (e.key === "ArrowRight") keysPressed.right = false;
        } catch (error) {
          console.error("Keyup error:", error);
        }
      });

      // Start button
      const startButton = document.getElementById("start-btn");
      if (startButton) {
        startButton.addEventListener("click", () => {
          try {
            if (startScreen) startScreen.style.display = "none";
            if (characterSelectScreen)
              characterSelectScreen.style.display = "flex";
          } catch (error) {
            console.error("Start button error:", error);
          }
        });
      }

      // Character selection
      const characterOptions = document.querySelectorAll(
        ".character-option.select-character"
      );
      characterOptions.forEach((option) => {
        option.addEventListener("click", () => {
          try {
            selectedCharacter = option.dataset.character;
            init();
            initAudioContext();
          } catch (error) {
            console.error("Character selection error:", error);
          }
        });
      });

      // Music track switch on end
      if (bgm) {
        bgm.addEventListener("ended", () => {
          nextTrack();
        });
      }

      // Farcade SDK
      if (window.FarcadeSDK) {
        window.FarcadeSDK.on("play_again", () => {
          try {
            // Show start screen on play again
            if (startScreen) {
              startScreen.style.display = "flex";
            }
            if (characterSelectScreen) {
              characterSelectScreen.style.display = "none";
            }
            selectedCharacter = null;
            gameStarted = false;
            gameOver = false;
          } catch (error) {
            console.error("Play again error:", error);
          }
        });

        window.FarcadeSDK.on("toggle_mute", (data) => {
          try {
            isMuted = data?.isMuted || false;
            if (bgm) bgm.muted = isMuted;
          } catch (error) {
            console.error("Toggle mute error:", error);
          }
        });
      }

      // Cleanup
      window.addEventListener("unload", () => {
        cleanupAudio();
      });

      updateUI();
      gameLoop();
    </script>
  </body>
</html>
