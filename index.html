<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Bubble Bluster</title>
    <script src="https://cdn.jsdelivr.net/npm/@farcade/game-sdk@latest/dist/index.min.js"></script>
    <style>
      body {
        margin: 0;
        padding: 0;
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
        font-family: "Courier New", monospace;
        overflow: hidden;
        touch-action: none;
      }
      #game-container {
        position: relative;
        max-width: 500px;
        width: 100%;
        max-height: 1000px;
        height: 100vh;
        /* Placeholder para la imagen; reemplaza con tu URL */
        background-image: url("https://w0.peakpx.com/wallpaper/85/248/HD-wallpaper-bubbles-air-bubble-glitter.jpg");
        background-size: cover;
        background-position: center;
        background-repeat: no-repeat;
        overflow: hidden;
        border: 4px solid #00ffcc;
        border-radius: 15px;
        box-shadow: 0 0 20px rgba(0, 255, 204, 0.5);
      }
      #game-canvas {
        display: block;
        width: 100%;
        height: calc(100% - 50px);
        position: absolute;
        top: 50px;
        background: rgba(
          45,
          45,
          45,
          0.7
        ); /* Fondo semi-transparente para visibilidad */
      }
      #header {
        position: absolute;
        top: 0;
        width: 100%;
        height: 50px;
        background: #1a1a1a;
        color: #00ffcc;
        font-size: clamp(16px, 4vw, 24px);
        text-shadow: 0 0 5px rgba(0, 255, 204, 0.7);
        text-align: center;
        line-height: 50px;
        pointer-events: none;
      }
      #next-bubbles {
        position: absolute;
        bottom: 20px;
        right: 20px;
        display: flex;
        flex-direction: row;
        gap: 10px;
      }
      .next-bubble {
        width: clamp(20px, 6vw, 30px);
        height: clamp(20px, 6vw, 30px);
        border-radius: 50%;
        border: 2px solid #fff;
      }
      #start-screen {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.5);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        color: #00ffcc;
        text-shadow: 0 0 5px rgba(0, 255, 204, 0.7);
        font-size: clamp(14px, 3vw, 18px);
      }
      #start-screen h1 {
        font-size: clamp(32px, 8vw, 48px);
        margin-bottom: 20px;

        text-transform: uppercase;
      }
      #start-screen p {
        text-align: center;
        margin-bottom: 30px;
        line-height: 1.5;
        max-width: 80%;
      }
      .btn {
        padding: clamp(10px, 3vw, 15px) clamp(20px, 5vw, 30px);
        font-size: clamp(16px, 4vw, 20px);
        cursor: pointer;
        background: #ff0066;
        color: white;
        border: none;
        border-radius: 10px;
        text-shadow: 0 0 5px rgba(255, 0, 102, 0.7);
      }
      .btn:hover {
        background: #ff3385;
      }
    </style>
  </head>
  <body>
    <div id="game-container">
      <div id="header">Score: <span id="score">20000</span></div>
      <canvas id="game-canvas"></canvas>
      <div id="next-bubbles">
        <div id="next1" class="next-bubble"></div>
        <div id="next2" class="next-bubble"></div>
      </div>
      <div id="start-screen">
        <h1>Bubble Bluster</h1>
        <p>
          Clear all bubbles fast!<br />
          Use ←→ or swipe to aim, Space or tap to shoot.<br />
          Break all bubbles before the score reaches zero!
        </p>
        <button id="start-btn" class="btn">Start Game</button>
      </div>
      <audio id="bgm" loop>
        <!-- Pista arcade gratuita; reemplaza si lo deseas -->
        <source
          src="https://cdn.pixabay.com/audio/2022/05/13/14-22-49-484_140k.mp3"
          type="audio/mpeg"
        />
        Your browser does not support the audio element.
      </audio>
    </div>

    <script>
      const canvas = document.getElementById("game-canvas");
      const ctx = canvas.getContext("2d");
      const scoreDisplay = document.getElementById("score");
      const next1 = document.getElementById("next1");
      const next2 = document.getElementById("next2");
      const startScreen = document.getElementById("start-screen");
      const startBtn = document.getElementById("start-btn");
      const bgm = document.getElementById("bgm");

      // Game constants
      const GRID_WIDTH = 8;
      let BUBBLE_SIZE;
      const GRID_HEIGHT = 14;
      const ALL_COLORS = [
        "#FF0000", // Rojo
        "#00FF00", // Verde
        "#0000FF", // Azul
        "#FFFF00", // Amarillo
        "#FF00FF", // Magenta
      ];
      let COLORS = [];
      const HEADER_HEIGHT = 50;
      let LIMIT_LINE_Y = 0;
      const INITIAL_SCORE = 20000; // 5 minutos a 66.67 puntos por segundo

      // Game state
      let grid = [];
      let currentBubble = null;
      let nextBubbles = [];
      let launcherAngle = Math.PI / 2;
      let score = INITIAL_SCORE;
      let gameOver = false;
      let gameStarted = false;
      let particles = [];
      let touchStartX = null;
      let keysPressed = { left: false, right: false };
      let keyPressedThisFrame = { left: false, right: false };
      let isMuted = false;
      let canShoot = true;

      // Resize canvas and set BUBBLE_SIZE
      function resizeCanvas() {
        const container = document.getElementById("game-container");
        canvas.width = Math.min(500, container.clientWidth);
        canvas.height = Math.min(1000, container.clientHeight) - HEADER_HEIGHT;
        BUBBLE_SIZE = canvas.width / GRID_WIDTH;
        LIMIT_LINE_Y = canvas.height - 120;
      }
      resizeCanvas();
      window.addEventListener("resize", resizeCanvas);

      // Initialize game
      function init() {
        grid = Array(GRID_HEIGHT)
          .fill()
          .map(() => Array(GRID_WIDTH).fill(null));
        const usedColors = new Set();
        for (let row = 0; row < 6; row++) {
          const isOddRow = row % 2 === 1;
          const numBubbles = isOddRow ? 7 : 8;
          for (let col = 0; col < numBubbles; col++) {
            const color =
              ALL_COLORS[Math.floor(Math.random() * ALL_COLORS.length)];
            grid[row][col] = color;
            usedColors.add(color);
          }
        }
        COLORS = Array.from(usedColors);
        nextBubbles = [getRandomColor(), getExistingColor()];
        spawnBubble();
        score = INITIAL_SCORE;
        gameOver = false;
        gameStarted = true;
        particles = [];
        canShoot = true;
        startScreen.style.display = "none";
        updateUI();
        if (!isMuted) bgm.play().catch(() => {}); // Reproducir música si no está silenciada
        window.FarcadeSDK.singlePlayer.actions.ready();
      }

      // Get a random color from available colors
      function getRandomColor() {
        return COLORS[Math.floor(Math.random() * COLORS.length)];
      }

      // Get a color that exists in the grid
      function getExistingColor() {
        const existingColors = new Set();
        for (let row = 0; row < GRID_HEIGHT; row++) {
          for (let col = 0; col < GRID_WIDTH; col++) {
            if (grid[row][col]) existingColors.add(grid[row][col]);
          }
        }
        const availableColors = Array.from(existingColors);
        return availableColors[
          Math.floor(Math.random() * availableColors.length)
        ];
      }

      // Spawn bubble for launcher
      function spawnBubble() {
        currentBubble = {
          x: canvas.width / 2,
          y: canvas.height - 20,
          color: nextBubbles.shift(),
          velocity: { x: 0, y: 0 },
          moving: false,
        };
        nextBubbles.push(getExistingColor());
        canShoot = true;
        updateUI();
      }

      // Snap bubble to grid
      function snapBubbleToGrid(bubble) {
        let pos = getGridPos(bubble.x, bubble.y);
        const isOddRow = pos.row % 2 === 1;
        const maxCols = isOddRow ? GRID_WIDTH - 1 : GRID_WIDTH;

        if (grid[pos.row][pos.col] || pos.col >= maxCols || pos.col < 0) {
          const emptyPos = findNearestEmptySpot(pos.row, pos.col, bubble);
          if (emptyPos) {
            pos = emptyPos;
          } else {
            for (let r = Math.max(0, pos.row - 1); r < GRID_HEIGHT; r++) {
              const rMaxCols = r % 2 === 1 ? GRID_WIDTH - 1 : GRID_WIDTH;
              for (let c = 0; c < rMaxCols; c++) {
                if (!grid[r][c] && (r === 0 || hasAdjacentBubble(r, c))) {
                  pos = { row: r, col: c };
                  break;
                }
              }
              if (
                pos.row === r &&
                (r === 0 || hasAdjacentBubble(pos.row, pos.col))
              )
                break;
            }
          }
        }

        if (pos.row !== 0 && !hasAdjacentBubble(pos.row, pos.col)) {
          for (
            let r = Math.max(0, pos.row - 1);
            r <= Math.min(GRID_HEIGHT - 1, pos.row + 1);
            r++
          ) {
            const rMaxCols = r % 2 === 1 ? GRID_WIDTH - 1 : GRID_WIDTH;
            for (let c = 0; c < rMaxCols; c++) {
              if (!grid[r][c] && (r === 0 || hasAdjacentBubble(r, c))) {
                pos = { row: r, col: c };
                break;
              }
            }
            if (
              pos.row === r &&
              (r === 0 || hasAdjacentBubble(pos.row, pos.col))
            )
              break;
          }
        }

        grid[pos.row][pos.col] = bubble.color;
        window.FarcadeSDK.singlePlayer.actions.hapticFeedback();
        checkAndRemoveMatches(pos.row, pos.col);
        currentBubble = null;

        if (isGridEmpty()) {
          gameOver = true;
          window.FarcadeSDK.singlePlayer.actions.gameOver({
            score: Math.floor(score),
          });
        } else {
          spawnBubble();
        }
      }

      // Check if grid is empty
      function isGridEmpty() {
        for (let row = 0; row < GRID_HEIGHT; row++) {
          for (let col = 0; col < GRID_WIDTH; col++) {
            if (grid[row][col]) return false;
          }
        }
        return true;
      }

      // Grid position calculations
      function getGridPos(x, y) {
        const row = Math.floor(y / ((BUBBLE_SIZE * Math.sqrt(3)) / 2));
        const isOddRow = row % 2 === 1;
        const colOffset = isOddRow ? BUBBLE_SIZE / 2 : 0;
        const col = Math.floor((x - colOffset) / BUBBLE_SIZE);
        return {
          row: Math.max(0, Math.min(GRID_HEIGHT - 1, row)),
          col: Math.max(
            0,
            Math.min(isOddRow ? GRID_WIDTH - 1 : GRID_WIDTH - 1, col)
          ),
        };
      }

      // Shooting mechanics
      function shootBubble() {
        if (currentBubble && !currentBubble.moving && canShoot) {
          currentBubble.velocity = {
            x: Math.cos(launcherAngle) * 10,
            y: -Math.sin(launcherAngle) * 10,
          };
          currentBubble.moving = true;
          canShoot = false;
          window.FarcadeSDK.singlePlayer.actions.hapticFeedback();
        }
      }

      // Find nearest empty spot
      function findNearestEmptySpot(row, col, bubble) {
        const candidates = [];
        const bubbleX = bubble.x;
        const bubbleY = bubble.y;

        for (
          let r = Math.max(0, row - 1);
          r <= Math.min(GRID_HEIGHT - 1, row + 1);
          r++
        ) {
          const rMaxCols = r % 2 === 1 ? GRID_WIDTH - 1 : GRID_WIDTH;
          for (let c = 0; c < rMaxCols; c++) {
            if (!grid[r][c] && (r === 0 || hasAdjacentBubble(r, c))) {
              const offset = r % 2 === 1 ? BUBBLE_SIZE / 2 : 0;
              const nx = c * BUBBLE_SIZE + offset + BUBBLE_SIZE / 2;
              const ny =
                r * ((BUBBLE_SIZE * Math.sqrt(3)) / 2) + BUBBLE_SIZE / 2;
              const dist = Math.hypot(nx - bubbleX, ny - bubbleY);
              candidates.push({ row: r, col: c, dist });
            }
          }
        }

        if (candidates.length === 0) return null;

        candidates.sort((a, b) => {
          if (Math.abs(a.dist - b.dist) < 0.01) {
            return Math.random() < 0.5 ? -1 : 1;
          }
          return a.dist - b.dist;
        });

        return candidates[0];
      }

      // Verificar si una posición tiene contacto con otra burbuja
      function hasAdjacentBubble(row, col) {
        const isOddRow = row % 2 === 1;
        const maxCols = isOddRow ? GRID_WIDTH - 1 : GRID_WIDTH;
        const neighbors = [
          { row: row - 1, col: col },
          { row: row + 1, col: col },
          { row: row, col: col - 1 },
          { row: row, col: col + 1 },
          { row: row - 1, col: isOddRow ? col + 1 : col - 1 },
          { row: row + 1, col: isOddRow ? col + 1 : col - 1 },
        ];

        for (let n of neighbors) {
          if (
            n.row >= 0 &&
            n.row < GRID_HEIGHT &&
            n.col >= 0 &&
            n.col < (n.row % 2 === 1 ? GRID_WIDTH - 1 : GRID_WIDTH) &&
            grid[n.row][n.col]
          ) {
            return true;
          }
        }
        return false;
      }

      // Check matches and remove them
      function checkAndRemoveMatches(row, col) {
        if (!grid[row][col]) return;
        const matches = checkMatches(row, col);
        if (matches.length >= 3) {
          matches.forEach(({ row, col }) => {
            createParticles(row, col, grid[row][col]);
            grid[row][col] = null;
          });
          window.FarcadeSDK.singlePlayer.actions.hapticFeedback();
          removeFloatingBubbles();
        }
      }

      // Match checking
      function checkMatches(row, col) {
        const color = grid[row][col];
        const visited = new Set();
        const toCheck = [{ row, col }];
        const matches = [];

        while (toCheck.length) {
          const { row: r, col: c } = toCheck.pop();
          const key = `${r},${c}`;
          const isOddRow = r % 2 === 1;
          if (
            visited.has(key) ||
            r < 0 ||
            r >= GRID_HEIGHT ||
            c < 0 ||
            c >= GRID_WIDTH ||
            grid[r][c] !== color
          )
            continue;

          visited.add(key);
          matches.push({ row: r, col: c });

          const neighbors = [
            { row: r - 1, col: c },
            { row: r + 1, col: c },
            { row: r, col: c - 1 },
            { row: r, col: c + 1 },
            { row: r - 1, col: isOddRow ? c + 1 : c - 1 },
            { row: r + 1, col: isOddRow ? c + 1 : c - 1 },
          ];
          toCheck.push(...neighbors);
        }
        return matches;
      }

      // Remove floating bubbles
      function removeFloatingBubbles() {
        const connected = new Set();
        const toCheck = [];

        for (let col = 0; col < GRID_WIDTH; col++) {
          if (grid[0][col]) {
            toCheck.push({ row: 0, col });
          }
        }

        while (toCheck.length) {
          const { row, col } = toCheck.pop();
          const key = `${row},${col}`;
          if (connected.has(key) || !grid[row][col]) continue;

          connected.add(key);

          const isOddRow = row % 2 === 1;
          const maxCols = isOddRow ? GRID_WIDTH - 1 : GRID_WIDTH;
          if (col >= maxCols) continue;

          const neighbors = [
            { row: row - 1, col: col },
            { row: row + 1, col: col },
            { row: row, col: col - 1 },
            { row: row, col: col + 1 },
            { row: row - 1, col: isOddRow ? col + 1 : col - 1 },
            { row: row + 1, col: isOddRow ? col + 1 : col - 1 },
          ];

          for (let n of neighbors) {
            if (
              n.row >= 0 &&
              n.row < GRID_HEIGHT &&
              n.col >= 0 &&
              n.col < (n.row % 2 === 1 ? GRID_WIDTH - 1 : GRID_WIDTH) &&
              grid[n.row][n.col]
            ) {
              toCheck.push(n);
            }
          }
        }

        for (let row = 0; row < GRID_HEIGHT; row++) {
          const maxCols = row % 2 === 1 ? GRID_WIDTH - 1 : GRID_WIDTH;
          for (let col = 0; col < maxCols; col++) {
            if (grid[row][col] && !connected.has(`${row},${col}`)) {
              createParticles(row, col, grid[row][col]);
              grid[row][col] = null;
            }
          }
        }
      }

      // Particle animation
      function createParticles(row, col, color) {
        for (let i = 0; i < 10; i++) {
          const offset = row % 2 === 1 ? BUBBLE_SIZE / 2 : 0;
          particles.push({
            x: col * BUBBLE_SIZE + offset + BUBBLE_SIZE / 2,
            y: row * ((BUBBLE_SIZE * Math.sqrt(3)) / 2),
            vx: (Math.random() - 0.5) * 6,
            vy: (Math.random() - 0.5) * 6,
            size: Math.random() * 6 + 2,
            color: color,
            life: 30,
          });
        }
      }

      // Calculate trajectory until collision
      function calculateTrajectoryAndCollision() {
        const launcherX = canvas.width / 2;
        const launcherY = canvas.height - 20;
        let x = launcherX;
        let y = launcherY;
        let vx = Math.cos(launcherAngle) * 5;
        let vy = -Math.sin(launcherAngle) * 5;
        const points = [];
        let collisionX, collisionY;

        while (y > 0) {
          points.push({ x, y });

          x += vx;
          y += vy;

          if (x < BUBBLE_SIZE / 2 || x > canvas.width - BUBBLE_SIZE / 2) {
            vx *= -1;
            x = Math.max(
              BUBBLE_SIZE / 2,
              Math.min(canvas.width - BUBBLE_SIZE / 2, x)
            );
          }

          const pos = getGridPos(x, y);
          for (
            let row = Math.max(0, pos.row - 1);
            row <= Math.min(GRID_HEIGHT - 1, pos.row + 1);
            row++
          ) {
            for (let col = 0; col < GRID_WIDTH; col++) {
              if (grid[row][col]) {
                const offset = row % 2 === 1 ? BUBBLE_SIZE / 2 : 0;
                const bubbleX = col * BUBBLE_SIZE + offset + BUBBLE_SIZE / 2;
                const bubbleY =
                  row * ((BUBBLE_SIZE * Math.sqrt(3)) / 2) + BUBBLE_SIZE / 2;
                if (Math.hypot(x - bubbleX, y - bubbleY) < BUBBLE_SIZE * 0.9) {
                  collisionX = x;
                  collisionY = y;
                  points.push({ x: collisionX, y: collisionY });
                  return { points, collisionX, collisionY };
                }
              }
            }
          }

          if (y < BUBBLE_SIZE / 2) {
            collisionX = x;
            collisionY = y;
            points.push({ x: collisionX, y: collisionY });
            return { points, collisionX, collisionY };
          }
        }
        collisionX = x;
        collisionY = y;
        points.push({ x: collisionX, y: collisionY });
        return { points, collisionX, collisionY };
      }

      // Update game state
      function update() {
        if (!gameStarted || gameOver) return;

        if (currentBubble && currentBubble.moving) {
          currentBubble.x += currentBubble.velocity.x;
          currentBubble.y += currentBubble.velocity.y;

          if (
            currentBubble.x < BUBBLE_SIZE / 2 ||
            currentBubble.x > canvas.width - BUBBLE_SIZE / 2
          ) {
            currentBubble.velocity.x *= -1;
            currentBubble.x = Math.max(
              BUBBLE_SIZE / 2,
              Math.min(canvas.width - BUBBLE_SIZE / 2, currentBubble.x)
            );
          }

          if (currentBubble.y < BUBBLE_SIZE / 2) {
            currentBubble.moving = false;
            snapBubbleToGrid(currentBubble);
            return;
          }

          const pos = getGridPos(currentBubble.x, currentBubble.y);
          for (
            let row = Math.max(0, pos.row - 1);
            row <= Math.min(GRID_HEIGHT - 1, pos.row + 1);
            row++
          ) {
            for (let col = 0; col < GRID_WIDTH; col++) {
              if (grid[row][col]) {
                const offset = row % 2 === 1 ? BUBBLE_SIZE / 2 : 0;
                const bubbleX = col * BUBBLE_SIZE + offset + BUBBLE_SIZE / 2;
                const bubbleY =
                  row * ((BUBBLE_SIZE * Math.sqrt(3)) / 2) + BUBBLE_SIZE / 2;
                if (
                  Math.hypot(
                    currentBubble.x - bubbleX,
                    currentBubble.y - bubbleY
                  ) <
                  BUBBLE_SIZE * 0.9
                ) {
                  currentBubble.moving = false;
                  snapBubbleToGrid(currentBubble);
                  return;
                }
              }
            }
          }
        }

        // Movimiento continuo del lanzador
        if (keysPressed.left) launcherAngle += 0.01;
        if (keysPressed.right) launcherAngle -= 0.01;
        launcherAngle = Math.max(
          Math.PI / 2 - 1.4835,
          Math.min(Math.PI / 2 + 1.4835, launcherAngle)
        );

        // Resetear flags de toque corto
        keyPressedThisFrame.left = false;
        keyPressedThisFrame.right = false;

        particles = particles.filter((p) => p.life > 0);
        particles.forEach((p) => {
          p.x += p.vx;
          p.y += p.vy;
          p.vy += 0.1;
          p.life--;
          p.size *= 0.95;
        });

        // Reducir score
        score = Math.max(0, score - 1.1111); // ~66.67 por segundo a 60 FPS
        updateUI();

        // Game Over si toca la línea púrpura o score llega a 0
        for (let row = 0; row < GRID_HEIGHT; row++) {
          for (let col = 0; col < GRID_WIDTH; col++) {
            if (
              grid[row][col] &&
              row * ((BUBBLE_SIZE * Math.sqrt(3)) / 2) + BUBBLE_SIZE >=
                LIMIT_LINE_Y
            ) {
              gameOver = true;
              window.FarcadeSDK.singlePlayer.actions.gameOver({
                score: Math.floor(score),
              });
            }
          }
        }

        if (score <= 0) {
          gameOver = true;
          window.FarcadeSDK.singlePlayer.actions.gameOver({ score: 0 });
        }
      }

      // Render game
      function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        if (gameStarted) {
          for (let y = 0; y < GRID_HEIGHT; y++) {
            for (let x = 0; x < GRID_WIDTH; x++) {
              if (grid[y][x]) {
                const offset = y % 2 === 1 ? BUBBLE_SIZE / 2 : 0;
                const bubbleX = x * BUBBLE_SIZE + offset;
                const bubbleY = y * ((BUBBLE_SIZE * Math.sqrt(3)) / 2);
                ctx.beginPath();
                ctx.arc(
                  bubbleX + BUBBLE_SIZE / 2,
                  bubbleY + BUBBLE_SIZE / 2,
                  BUBBLE_SIZE / 2 - 2,
                  0,
                  Math.PI * 2
                );
                ctx.fillStyle = grid[y][x];
                ctx.fill();
                ctx.strokeStyle = "#fff";
                ctx.lineWidth = 2;
                ctx.stroke();
              }
            }
          }

          if (currentBubble) {
            ctx.beginPath();
            ctx.arc(
              currentBubble.x,
              currentBubble.y,
              BUBBLE_SIZE / 2 - 2,
              0,
              Math.PI * 2
            );
            ctx.fillStyle = currentBubble.color;
            ctx.fill();
            ctx.strokeStyle = "#fff";
            ctx.stroke();
          }

          const launcherX = canvas.width / 2;
          const launcherY = canvas.height - 20;
          const circleRadius = 40;
          const arrowLength = 80;

          ctx.beginPath();
          ctx.arc(launcherX, launcherY, circleRadius, 0, Math.PI * 2);
          ctx.strokeStyle = "#ff0066";
          ctx.lineWidth = 2;
          ctx.stroke();

          const arrowStartX = launcherX;
          const arrowStartY = launcherY;
          const arrowEndX = arrowStartX + Math.cos(launcherAngle) * arrowLength;
          const arrowEndY = arrowStartY - Math.sin(launcherAngle) * arrowLength;

          ctx.beginPath();
          ctx.moveTo(arrowStartX, arrowStartY);
          ctx.lineTo(arrowEndX, arrowEndY);
          ctx.strokeStyle = "#ff0066";
          ctx.lineWidth = 4;
          ctx.stroke();

          ctx.beginPath();
          ctx.moveTo(arrowEndX, arrowEndY);
          ctx.lineTo(
            arrowEndX - Math.cos(launcherAngle + Math.PI / 6) * 15,
            arrowEndY + Math.sin(launcherAngle + Math.PI / 6) * 15
          );
          ctx.moveTo(arrowEndX, arrowEndY);
          ctx.lineTo(
            arrowEndX - Math.cos(launcherAngle - Math.PI / 6) * 15,
            arrowEndY + Math.sin(launcherAngle - Math.PI / 6) * 15
          );
          ctx.stroke();

          if (currentBubble && !currentBubble.moving) {
            const { points, collisionX, collisionY } =
              calculateTrajectoryAndCollision();
            points.forEach((point, i) => {
              if (i % 4 === 0) {
                ctx.beginPath();
                ctx.arc(point.x, point.y, 2, 0, Math.PI * 2);
                ctx.fillStyle = "#00ffcc";
                ctx.fill();
              }
            });
            ctx.beginPath();
            ctx.arc(collisionX, collisionY, 4, 0, Math.PI * 2);
            ctx.fillStyle = "#ff0066";
            ctx.fill();
          }

          particles.forEach((p) => {
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
            ctx.fillStyle = p.color;
            ctx.fill();
          });

          ctx.beginPath();
          ctx.moveTo(0, LIMIT_LINE_Y);
          ctx.lineTo(canvas.width, LIMIT_LINE_Y);
          ctx.strokeStyle = "#ff0066";
          ctx.lineWidth = 2;
          ctx.stroke();
        }
      }

      // Update UI
      function updateUI() {
        scoreDisplay.textContent = Math.floor(score);
        next1.style.backgroundColor = nextBubbles[0] || "#ffffff";
        next2.style.backgroundColor = nextBubbles[1] || "#ffffff";
      }

      // Game loop
      function gameLoop() {
        update();
        draw();
        requestAnimationFrame(gameLoop);
      }

      // Keyboard input handling
      document.addEventListener("keydown", (e) => {
        if (gameStarted && !gameOver) {
          if (e.key === "ArrowLeft" && !keysPressed.left) {
            keysPressed.left = true;
            keyPressedThisFrame.left = true;
            launcherAngle += 0.002;
          }
          if (e.key === "ArrowRight" && !keysPressed.right) {
            keysPressed.right = true;
            keyPressedThisFrame.right = true;
            launcherAngle -= 0.002;
          }
          if (e.key === " ") {
            e.preventDefault();
            shootBubble();
          }
          launcherAngle = Math.max(
            Math.PI / 2 - 1.4835,
            Math.min(Math.PI / 2 + 1.4835, launcherAngle)
          );
        }
      });

      document.addEventListener("keyup", (e) => {
        if (e.key === "ArrowLeft") keysPressed.left = false;
        if (e.key === "ArrowRight") keysPressed.right = false;
      });

      // Touch input handling
      canvas.addEventListener("touchstart", (e) => {
        e.preventDefault();
        const touch = e.touches[0];
        touchStartX = touch.clientX;

        if (gameStarted && !gameOver) {
          setTimeout(() => {
            if (touchStartX !== null) shootBubble();
          }, 100);
        }
      });

      canvas.addEventListener("touchmove", (e) => {
        e.preventDefault();
        if (gameStarted && !gameOver && touchStartX !== null) {
          const touch = e.touches[0];
          const deltaX = touch.clientX - touchStartX;
          launcherAngle -= deltaX * 0.005;
          launcherAngle = Math.max(
            Math.PI / 2 - 1.4835,
            Math.min(Math.PI / 2 + 1.4835, launcherAngle)
          );
          touchStartX = touch.clientX;
        }
      });

      canvas.addEventListener("touchend", (e) => {
        e.preventDefault();
        touchStartX = null;
      });

      startBtn.addEventListener("click", () => {
        init();
      });

      // Farcade SDK event handlers
      window.FarcadeSDK.on("play_again", () => {
        init();
      });

      window.FarcadeSDK.on("toggle_mute", (data) => {
        isMuted = data.isMuted;
        bgm.muted = isMuted;
      });

      updateUI();
      gameLoop();
    </script>
  </body>
</html>
